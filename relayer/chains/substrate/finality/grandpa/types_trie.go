package grandpa

type TimeStampExtWithProof struct {
	/// The timestamp inherent SCALE-encoded bytes. Decode with [`UncheckedExtrinsic`]
	Ext []byte
	/// Merkle-patricia trie existence proof for the extrinsic, this is generated by the relayer.
	//SAM127Proof TrieProof
}

/*type TrieDBMut struct {
	db   unsafe.Pointer
	root unsafe.Pointer
	trie unsafe.Pointer
}

func NewTrieDBMut() *TrieDBMut {
	var db unsafe.Pointer
	var root unsafe.Pointer
	var trie unsafe.Pointer

	C.ext_TrieDBMut_LayoutV0_BlakeTwo256_new(&trie, &db, &root)
	return &TrieDBMut{
		db:   db,
		root: root,
		trie: trie,
	}
}

func (t *TrieDBMut) Free() {
	C.ext_TrieDBMut_LayoutV0_BlakeTwo256_free(t.trie, t.db, t.root)
}

func (t *TrieDBMut) Insert(key []byte, value []byte) {
	C.ext_TrieDBMut_LayoutV0_BlakeTwo256_insert(
		t.trie,
		(*C.uint8_t)(unsafe.Pointer(&key[0])),
		C.size_t(len(key)),
		(*C.uint8_t)(unsafe.Pointer(&value[0])),
		C.size_t(len(value)),
	)
}

func (t *TrieDBMut) Root() rpctypes.Hash {
	var root rpctypes.Hash
	C.ext_TrieDBMut_LayoutV0_BlakeTwo256_root(t.trie, unsafe.Pointer(&root))
	return root
}

type TrieProof struct {
	// The proof is built from `items` and `lengths` fields and points to the data in `items`
	Proof   [][]byte
	items   []*C.uchar
	lengths []C.size_t
}

// NewTrieProofFromRaw construct TrieProof
// # Safety
// TODO
// Ref: https://zchee.github.io/golang-wiki/cgo/#turning-c-arrays-into-go-slices
func NewTrieProofFromRaw(proofItemsAddr **C.uint8_t, proofLensAddr *C.size_t, proofLen uint) TrieProof {
	items := unsafe.Slice(&*proofItemsAddr, proofLen)
	lens := unsafe.Slice(&*proofLensAddr, proofLen)

	proof := make([][]byte, proofLen)
	for i := 0; i < int(proofLen); i++ {
		proof[i] = C.GoBytes(
			unsafe.Pointer(items[i]),
			C.int(lens[i]),
		)
	}

	return TrieProof{
		Proof:   proof,
		items:   items,
		lengths: lens,
	}
}

func NewTrieProof(proof [][]byte) TrieProof {
	items := make([]*C.uchar, len(proof))
	lengths := make([]C.size_t, len(proof))
	for i := 0; i < len(proof); i++ {
		items[i] = (*C.uchar)(unsafe.Pointer(&proof[i][0]))
		lengths[i] = C.size_t(len(proof[i]))
	}

	return TrieProof{
		Proof:   proof,
		items:   items,
		lengths: lengths,
	}
}

func (t *TrieProof) Free() {
	C.free(unsafe.Pointer(&t.items[0]))
	C.free(unsafe.Pointer(&t.lengths[0]))
}

func (t *TrieDBMut) GenerateTrieProof(root rpctypes.Hash, key []byte) TrieProof {
	var proofItemsAddr **C.uint8_t
	var proofLensAddr *C.size_t
	var proofLen C.size_t

	rootPtr := unsafe.Pointer(&root)
	C.ext_TrieDBMut_LayoutV0_BlakeTwo256_generate_trie_proof(
		t.db,
		rootPtr,
		(*C.uint8_t)(unsafe.Pointer(&key[0])),
		C.size_t(len(key)),
		&proofItemsAddr,
		&proofLensAddr,
		&proofLen,
	)

	return NewTrieProofFromRaw(proofItemsAddr, proofLensAddr, uint(proofLen))
}

// VerifyTrieProof Proof.items and Proof.lengths fields are used as pointers to proof data
func (t *TrieDBMut) VerifyTrieProof(
	root rpctypes.Hash,
	key []byte,
	value []byte,
	proof TrieProof,
) bool {
	if len(proof.items) != len(proof.lengths) {
		panic("proof items and lengths length mismatch")
	}
	rootPtr := unsafe.Pointer(&root)
	keyPtr := unsafe.Pointer(&key[0])
	valuePtr := unsafe.Pointer(&value[0])
	proofItemsAddr := unsafe.Pointer(&proof.items[0])
	proofLensAddr := unsafe.Pointer(&proof.lengths[0])
	proofLen := C.size_t(len(proof.items))

	return bool(C.ext_TrieDBMut_LayoutV0_BlakeTwo256_verify_trie_proof(
		rootPtr,
		(*C.uint8_t)(keyPtr),
		C.size_t(len(key)),
		(*C.uint8_t)(valuePtr),
		C.size_t(len(value)),
		(**C.uint8_t)(proofItemsAddr),
		(*C.size_t)(proofLensAddr),
		proofLen,
	))
}

func ReadProofCheck(root rpctypes.Hash, proof TrieProof, key []byte) ([]byte, bool) {
	var value *C.uint8_t
	var valueLen C.size_t

	res := bool(C.ext_TrieDBMut_LayoutV0_BlakeTwo256_read_proof_check(
		unsafe.Pointer(&root),
		(*C.uint8_t)(unsafe.Pointer(&key[0])),
		C.size_t(len(key)),
		(**C.uint8_t)(unsafe.Pointer(&proof.items[0])),
		(*C.size_t)(unsafe.Pointer(&proof.lengths[0])),
		C.size_t(len(proof.items)),
		&value,
		&valueLen,
	))
	if !res {
		return nil, false
	}
	return C.GoBytes(unsafe.Pointer(value), C.int(valueLen)), true
}*/
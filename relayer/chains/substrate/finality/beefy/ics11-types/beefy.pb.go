// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: substrate/beefy.proto

package ics11_types

import (
	fmt "fmt"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	github_com_cosmos_gogoproto_types "github.com/cosmos/gogoproto/types"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// RelayChain types
type RelayChain int32

const (
	// Polkdator relay chain
	RelayChain_POLKADOT RelayChain = 0
	// Kusama relay chain
	RelayChain_KUSAMA RelayChain = 1
	// Rococo relay chain
	RelayChain_ROCOCO RelayChain = 2
)

var RelayChain_name = map[int32]string{
	0: "POLKADOT",
	1: "KUSAMA",
	2: "ROCOCO",
}

var RelayChain_value = map[string]int32{
	"POLKADOT": 0,
	"KUSAMA":   1,
	"ROCOCO":   2,
}

func (x RelayChain) String() string {
	return proto.EnumName(RelayChain_name, int32(x))
}

func (RelayChain) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_7a90d4515db3d1ab, []int{0}
}

// ClientState from Beefy tracks the current validator set, latest height,
// and a possible frozen height.
type ClientState struct {
	// Latest mmr root hash
	MmrRootHash []byte `protobuf:"bytes,1,opt,name=mmr_root_hash,json=mmrRootHash,proto3" json:"mmr_root_hash,omitempty"`
	// block number for the latest mmr_root_hash
	LatestBeefyHeight uint32 `protobuf:"varint,2,opt,name=latest_beefy_height,json=latestBeefyHeight,proto3" json:"latest_beefy_height,omitempty"`
	// Types that are valid to be assigned to XFrozenHeight:
	//	*ClientState_FrozenHeight
	XFrozenHeight isClientState_XFrozenHeight `protobuf_oneof:"_frozen_height"`
	/// Known relay chains
	RelayChain RelayChain `protobuf:"varint,4,opt,name=relay_chain,json=relayChain,proto3,enum=ibc.lightclients.beefy.v1.RelayChain" json:"relay_chain,omitempty"`
	/// ParaId of associated parachain
	ParaId uint32 `protobuf:"varint,5,opt,name=para_id,json=paraId,proto3" json:"para_id,omitempty"`
	/// latest parachain height
	LatestParaHeight uint32 `protobuf:"varint,6,opt,name=latest_para_height,json=latestParaHeight,proto3" json:"latest_para_height,omitempty"`
	// authorities for the current round
	Authority *BeefyAuthoritySet `protobuf:"bytes,8,opt,name=authority,proto3" json:"authority,omitempty"`
	// authorities for the next round
	NextAuthoritySet *BeefyAuthoritySet `protobuf:"bytes,9,opt,name=next_authority_set,json=nextAuthoritySet,proto3" json:"next_authority_set,omitempty"`
}

func (m *ClientState) Reset()         { *m = ClientState{} }
func (m *ClientState) String() string { return proto.CompactTextString(m) }
func (*ClientState) ProtoMessage()    {}
func (*ClientState) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a90d4515db3d1ab, []int{0}
}
func (m *ClientState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClientState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClientState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClientState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientState.Merge(m, src)
}
func (m *ClientState) XXX_Size() int {
	return m.Size()
}
func (m *ClientState) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientState.DiscardUnknown(m)
}

var xxx_messageInfo_ClientState proto.InternalMessageInfo

type isClientState_XFrozenHeight interface {
	isClientState_XFrozenHeight()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ClientState_FrozenHeight struct {
	FrozenHeight uint64 `protobuf:"varint,3,opt,name=frozen_height,json=frozenHeight,proto3,oneof" json:"frozen_height,omitempty"`
}

func (*ClientState_FrozenHeight) isClientState_XFrozenHeight() {}

func (m *ClientState) GetXFrozenHeight() isClientState_XFrozenHeight {
	if m != nil {
		return m.XFrozenHeight
	}
	return nil
}

func (m *ClientState) GetFrozenHeight() uint64 {
	if x, ok := m.GetXFrozenHeight().(*ClientState_FrozenHeight); ok {
		return x.FrozenHeight
	}
	return 0
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ClientState) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ClientState_FrozenHeight)(nil),
	}
}

// Actual payload items
type PayloadItem struct {
	// 2-byte payload id
	PayloadId []byte `protobuf:"bytes,1,opt,name=payload_id,json=payloadId,proto3" json:"payload_id,omitempty"`
	// arbitrary length payload data., eg mmr_root_hash
	PayloadData []byte `protobuf:"bytes,2,opt,name=payload_data,json=payloadData,proto3" json:"payload_data,omitempty"`
}

func (m *PayloadItem) Reset()         { *m = PayloadItem{} }
func (m *PayloadItem) String() string { return proto.CompactTextString(m) }
func (*PayloadItem) ProtoMessage()    {}
func (*PayloadItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a90d4515db3d1ab, []int{1}
}
func (m *PayloadItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PayloadItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PayloadItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PayloadItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PayloadItem.Merge(m, src)
}
func (m *PayloadItem) XXX_Size() int {
	return m.Size()
}
func (m *PayloadItem) XXX_DiscardUnknown() {
	xxx_messageInfo_PayloadItem.DiscardUnknown(m)
}

var xxx_messageInfo_PayloadItem proto.InternalMessageInfo

// Commitment message signed by beefy validators
type Commitment struct {
	// array of payload items signed by Beefy validators
	Payload []*PayloadItem `protobuf:"bytes,1,rep,name=payload,proto3" json:"payload,omitempty"`
	// block number for this commitment
	BlockNumer uint32 `protobuf:"varint,2,opt,name=block_numer,json=blockNumer,proto3" json:"block_numer,omitempty"`
	// validator set that signed this commitment
	ValidatorSetId uint64 `protobuf:"varint,3,opt,name=validator_set_id,json=validatorSetId,proto3" json:"validator_set_id,omitempty"`
}

func (m *Commitment) Reset()         { *m = Commitment{} }
func (m *Commitment) String() string { return proto.CompactTextString(m) }
func (*Commitment) ProtoMessage()    {}
func (*Commitment) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a90d4515db3d1ab, []int{2}
}
func (m *Commitment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Commitment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Commitment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Commitment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Commitment.Merge(m, src)
}
func (m *Commitment) XXX_Size() int {
	return m.Size()
}
func (m *Commitment) XXX_DiscardUnknown() {
	xxx_messageInfo_Commitment.DiscardUnknown(m)
}

var xxx_messageInfo_Commitment proto.InternalMessageInfo

// Signature belonging to a single validator
type CommitmentSignature struct {
	// actual signature bytes
	Signature []byte `protobuf:"bytes,1,opt,name=signature,proto3" json:"signature,omitempty"`
	// authority leaf index in the merkle tree.
	AuthorityIndex uint32 `protobuf:"varint,2,opt,name=authority_index,json=authorityIndex,proto3" json:"authority_index,omitempty"`
}

func (m *CommitmentSignature) Reset()         { *m = CommitmentSignature{} }
func (m *CommitmentSignature) String() string { return proto.CompactTextString(m) }
func (*CommitmentSignature) ProtoMessage()    {}
func (*CommitmentSignature) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a90d4515db3d1ab, []int{3}
}
func (m *CommitmentSignature) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommitmentSignature) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommitmentSignature.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommitmentSignature) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommitmentSignature.Merge(m, src)
}
func (m *CommitmentSignature) XXX_Size() int {
	return m.Size()
}
func (m *CommitmentSignature) XXX_DiscardUnknown() {
	xxx_messageInfo_CommitmentSignature.DiscardUnknown(m)
}

var xxx_messageInfo_CommitmentSignature proto.InternalMessageInfo

// signed commitment data
type SignedCommitment struct {
	// commitment data being signed
	Commitment *Commitment `protobuf:"bytes,1,opt,name=commitment,proto3" json:"commitment,omitempty"`
	// gotten from rpc subscription
	Signatures []*CommitmentSignature `protobuf:"bytes,2,rep,name=signatures,proto3" json:"signatures,omitempty"`
}

func (m *SignedCommitment) Reset()         { *m = SignedCommitment{} }
func (m *SignedCommitment) String() string { return proto.CompactTextString(m) }
func (*SignedCommitment) ProtoMessage()    {}
func (*SignedCommitment) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a90d4515db3d1ab, []int{4}
}
func (m *SignedCommitment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SignedCommitment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SignedCommitment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SignedCommitment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignedCommitment.Merge(m, src)
}
func (m *SignedCommitment) XXX_Size() int {
	return m.Size()
}
func (m *SignedCommitment) XXX_DiscardUnknown() {
	xxx_messageInfo_SignedCommitment.DiscardUnknown(m)
}

var xxx_messageInfo_SignedCommitment proto.InternalMessageInfo

// data needed to update the client
type ClientStateUpdateProof struct {
	MmrLeaf *BeefyMmrLeaf `protobuf:"bytes,1,opt,name=mmr_leaf,json=mmrLeaf,proto3" json:"mmr_leaf,omitempty"`
	// leaf index for the mmr_leaf
	MmrLeafIndex uint64 `protobuf:"varint,2,opt,name=mmr_leaf_index,json=mmrLeafIndex,proto3" json:"mmr_leaf_index,omitempty"`
	// proof that this mmr_leaf index is valid.
	MmrProof [][]byte `protobuf:"bytes,3,rep,name=mmr_proof,json=mmrProof,proto3" json:"mmr_proof,omitempty"`
	// signed commitment data
	SignedCommitment *SignedCommitment `protobuf:"bytes,4,opt,name=signed_commitment,json=signedCommitment,proto3" json:"signed_commitment,omitempty"`
	// generated using full authority list from runtime
	AuthoritiesProof [][]byte `protobuf:"bytes,5,rep,name=authorities_proof,json=authoritiesProof,proto3" json:"authorities_proof,omitempty"`
}

func (m *ClientStateUpdateProof) Reset()         { *m = ClientStateUpdateProof{} }
func (m *ClientStateUpdateProof) String() string { return proto.CompactTextString(m) }
func (*ClientStateUpdateProof) ProtoMessage()    {}
func (*ClientStateUpdateProof) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a90d4515db3d1ab, []int{5}
}
func (m *ClientStateUpdateProof) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClientStateUpdateProof) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClientStateUpdateProof.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClientStateUpdateProof) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientStateUpdateProof.Merge(m, src)
}
func (m *ClientStateUpdateProof) XXX_Size() int {
	return m.Size()
}
func (m *ClientStateUpdateProof) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientStateUpdateProof.DiscardUnknown(m)
}

var xxx_messageInfo_ClientStateUpdateProof proto.InternalMessageInfo

// ConsensusState defines the consensus state from Tendermint.
type ConsensusState struct {
	// timestamp that corresponds to the block height in which the ConsensusState
	// was stored.
	Timestamp time.Time `protobuf:"bytes,1,opt,name=timestamp,proto3,stdtime" json:"timestamp"`
	// packet commitment root
	Root []byte `protobuf:"bytes,2,opt,name=root,proto3" json:"root,omitempty"`
}

func (m *ConsensusState) Reset()         { *m = ConsensusState{} }
func (m *ConsensusState) String() string { return proto.CompactTextString(m) }
func (*ConsensusState) ProtoMessage()    {}
func (*ConsensusState) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a90d4515db3d1ab, []int{6}
}
func (m *ConsensusState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConsensusState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConsensusState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConsensusState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConsensusState.Merge(m, src)
}
func (m *ConsensusState) XXX_Size() int {
	return m.Size()
}
func (m *ConsensusState) XXX_DiscardUnknown() {
	xxx_messageInfo_ConsensusState.DiscardUnknown(m)
}

var xxx_messageInfo_ConsensusState proto.InternalMessageInfo

// Header contains the neccessary data to prove finality about IBC commitments
type Header struct {
	// optional payload to update ConsensusState
	ConsensusState *ConsensusStateUpdateProof `protobuf:"bytes,1,opt,name=consensus_state,json=consensusState,proto3" json:"consensus_state,omitempty"`
	// optional payload to update the ClientState.
	ClientState *ClientStateUpdateProof `protobuf:"bytes,2,opt,name=client_state,json=clientState,proto3" json:"client_state,omitempty"`
}

func (m *Header) Reset()         { *m = Header{} }
func (m *Header) String() string { return proto.CompactTextString(m) }
func (*Header) ProtoMessage()    {}
func (*Header) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a90d4515db3d1ab, []int{7}
}
func (m *Header) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Header) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Header.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Header) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Header.Merge(m, src)
}
func (m *Header) XXX_Size() int {
	return m.Size()
}
func (m *Header) XXX_DiscardUnknown() {
	xxx_messageInfo_Header.DiscardUnknown(m)
}

var xxx_messageInfo_Header proto.InternalMessageInfo

// / Parachain headers and their mmr proofs.
type ConsensusStateUpdateProof struct {
	// parachain headers needed for proofs and ConsensusState
	ParachainHeaders []*ParachainHeader `protobuf:"bytes,1,rep,name=parachain_headers,json=parachainHeaders,proto3" json:"parachain_headers,omitempty"`
	// mmr proofs for the headers gotten from rpc "mmr_generateProofs"
	MmrProofs [][]byte `protobuf:"bytes,2,rep,name=mmr_proofs,json=mmrProofs,proto3" json:"mmr_proofs,omitempty"`
	// size of the mmr for the given proof
	MmrSize uint64 `protobuf:"varint,3,opt,name=mmr_size,json=mmrSize,proto3" json:"mmr_size,omitempty"`
	// Leaf indices for the mmr proof
	LeafIndices []uint64 `protobuf:"varint,4,rep,packed,name=leaf_indices,json=leafIndices,proto3" json:"leaf_indices,omitempty"`
	// Leaf count
	LeafCount uint64 `protobuf:"varint,5,opt,name=leaf_count,json=leafCount,proto3" json:"leaf_count,omitempty"`
}

func (m *ConsensusStateUpdateProof) Reset()         { *m = ConsensusStateUpdateProof{} }
func (m *ConsensusStateUpdateProof) String() string { return proto.CompactTextString(m) }
func (*ConsensusStateUpdateProof) ProtoMessage()    {}
func (*ConsensusStateUpdateProof) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a90d4515db3d1ab, []int{8}
}
func (m *ConsensusStateUpdateProof) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConsensusStateUpdateProof) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConsensusStateUpdateProof.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConsensusStateUpdateProof) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConsensusStateUpdateProof.Merge(m, src)
}
func (m *ConsensusStateUpdateProof) XXX_Size() int {
	return m.Size()
}
func (m *ConsensusStateUpdateProof) XXX_DiscardUnknown() {
	xxx_messageInfo_ConsensusStateUpdateProof.DiscardUnknown(m)
}

var xxx_messageInfo_ConsensusStateUpdateProof proto.InternalMessageInfo

// data needed to prove parachain header inclusion in mmr.
type ParachainHeader struct {
	// scale-encoded parachain header bytes
	ParachainHeader []byte `protobuf:"bytes,1,opt,name=parachain_header,json=parachainHeader,proto3" json:"parachain_header,omitempty"`
	// see beefy spec
	MmrLeafPartial *BeefyMmrLeafPartial `protobuf:"bytes,2,opt,name=mmr_leaf_partial,json=mmrLeafPartial,proto3" json:"mmr_leaf_partial,omitempty"`
	// proofs for our header in the parachain heads root
	ParachainHeadsProof [][]byte `protobuf:"bytes,3,rep,name=parachain_heads_proof,json=parachainHeadsProof,proto3" json:"parachain_heads_proof,omitempty"`
	// leaf index for parachain heads proof
	HeadsLeafIndex uint32 `protobuf:"varint,4,opt,name=heads_leaf_index,json=headsLeafIndex,proto3" json:"heads_leaf_index,omitempty"`
	// total number of para heads in parachain_heads_root
	HeadsTotalCount uint32 `protobuf:"varint,5,opt,name=heads_total_count,json=headsTotalCount,proto3" json:"heads_total_count,omitempty"`
	// trie merkle proof of inclusion in header.extrinsic_root
	ExtrinsicProof [][]byte `protobuf:"bytes,6,rep,name=extrinsic_proof,json=extrinsicProof,proto3" json:"extrinsic_proof,omitempty"`
	// the actual timestamp extrinsic
	TimestampExtrinsic []byte `protobuf:"bytes,7,opt,name=timestamp_extrinsic,json=timestampExtrinsic,proto3" json:"timestamp_extrinsic,omitempty"`
}

func (m *ParachainHeader) Reset()         { *m = ParachainHeader{} }
func (m *ParachainHeader) String() string { return proto.CompactTextString(m) }
func (*ParachainHeader) ProtoMessage()    {}
func (*ParachainHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a90d4515db3d1ab, []int{9}
}
func (m *ParachainHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ParachainHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ParachainHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ParachainHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ParachainHeader.Merge(m, src)
}
func (m *ParachainHeader) XXX_Size() int {
	return m.Size()
}
func (m *ParachainHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_ParachainHeader.DiscardUnknown(m)
}

var xxx_messageInfo_ParachainHeader proto.InternalMessageInfo

// Partial data for MmrLeaf
type BeefyMmrLeafPartial struct {
	// leaf version
	Version uint32 `protobuf:"varint,1,opt,name=version,proto3" json:"version,omitempty"`
	// parent block for this leaf
	ParentNumber uint32 `protobuf:"varint,2,opt,name=parent_number,json=parentNumber,proto3" json:"parent_number,omitempty"`
	// parent hash for this leaf
	ParentHash []byte `protobuf:"bytes,3,opt,name=parent_hash,json=parentHash,proto3" json:"parent_hash,omitempty"`
	// next authority set.
	BeefyNextAuthoritySet *BeefyAuthoritySet `protobuf:"bytes,4,opt,name=beefy_next_authority_set,json=beefyNextAuthoritySet,proto3" json:"beefy_next_authority_set,omitempty"`
}

func (m *BeefyMmrLeafPartial) Reset()         { *m = BeefyMmrLeafPartial{} }
func (m *BeefyMmrLeafPartial) String() string { return proto.CompactTextString(m) }
func (*BeefyMmrLeafPartial) ProtoMessage()    {}
func (*BeefyMmrLeafPartial) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a90d4515db3d1ab, []int{10}
}
func (m *BeefyMmrLeafPartial) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BeefyMmrLeafPartial) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BeefyMmrLeafPartial.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BeefyMmrLeafPartial) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BeefyMmrLeafPartial.Merge(m, src)
}
func (m *BeefyMmrLeafPartial) XXX_Size() int {
	return m.Size()
}
func (m *BeefyMmrLeafPartial) XXX_DiscardUnknown() {
	xxx_messageInfo_BeefyMmrLeafPartial.DiscardUnknown(m)
}

var xxx_messageInfo_BeefyMmrLeafPartial proto.InternalMessageInfo

// Beefy Authority Info
type BeefyAuthoritySet struct {
	// Id of the authority set, it should be strictly increasing
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// size of the authority set
	Len uint32 `protobuf:"varint,2,opt,name=len,proto3" json:"len,omitempty"`
	// merkle root of the sorted authority public keys.
	AuthorityRoot []byte `protobuf:"bytes,3,opt,name=authority_root,json=authorityRoot,proto3" json:"authority_root,omitempty"`
}

func (m *BeefyAuthoritySet) Reset()         { *m = BeefyAuthoritySet{} }
func (m *BeefyAuthoritySet) String() string { return proto.CompactTextString(m) }
func (*BeefyAuthoritySet) ProtoMessage()    {}
func (*BeefyAuthoritySet) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a90d4515db3d1ab, []int{11}
}
func (m *BeefyAuthoritySet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BeefyAuthoritySet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BeefyAuthoritySet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BeefyAuthoritySet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BeefyAuthoritySet.Merge(m, src)
}
func (m *BeefyAuthoritySet) XXX_Size() int {
	return m.Size()
}
func (m *BeefyAuthoritySet) XXX_DiscardUnknown() {
	xxx_messageInfo_BeefyAuthoritySet.DiscardUnknown(m)
}

var xxx_messageInfo_BeefyAuthoritySet proto.InternalMessageInfo

// BeefyMmrLeaf leaf data
type BeefyMmrLeaf struct {
	// leaf version
	Version uint32 `protobuf:"varint,1,opt,name=version,proto3" json:"version,omitempty"`
	// parent block for this leaf
	ParentNumber uint32 `protobuf:"varint,2,opt,name=parent_number,json=parentNumber,proto3" json:"parent_number,omitempty"`
	// parent hash for this leaf
	ParentHash []byte `protobuf:"bytes,3,opt,name=parent_hash,json=parentHash,proto3" json:"parent_hash,omitempty"`
	// beefy next authority set.
	BeefyNextAuthoritySet *BeefyAuthoritySet `protobuf:"bytes,4,opt,name=beefy_next_authority_set,json=beefyNextAuthoritySet,proto3" json:"beefy_next_authority_set,omitempty"`
	// merkle root hash of parachain heads included in the leaf.
	ParachainHeads []byte `protobuf:"bytes,5,opt,name=parachain_heads,json=parachainHeads,proto3" json:"parachain_heads,omitempty"`
}

func (m *BeefyMmrLeaf) Reset()         { *m = BeefyMmrLeaf{} }
func (m *BeefyMmrLeaf) String() string { return proto.CompactTextString(m) }
func (*BeefyMmrLeaf) ProtoMessage()    {}
func (*BeefyMmrLeaf) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a90d4515db3d1ab, []int{12}
}
func (m *BeefyMmrLeaf) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BeefyMmrLeaf) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BeefyMmrLeaf.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BeefyMmrLeaf) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BeefyMmrLeaf.Merge(m, src)
}
func (m *BeefyMmrLeaf) XXX_Size() int {
	return m.Size()
}
func (m *BeefyMmrLeaf) XXX_DiscardUnknown() {
	xxx_messageInfo_BeefyMmrLeaf.DiscardUnknown(m)
}

var xxx_messageInfo_BeefyMmrLeaf proto.InternalMessageInfo

// BEEFY misbehaviour type
type Misbehaviour struct {
}

func (m *Misbehaviour) Reset()         { *m = Misbehaviour{} }
func (m *Misbehaviour) String() string { return proto.CompactTextString(m) }
func (*Misbehaviour) ProtoMessage()    {}
func (*Misbehaviour) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a90d4515db3d1ab, []int{13}
}
func (m *Misbehaviour) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Misbehaviour) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Misbehaviour.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Misbehaviour) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Misbehaviour.Merge(m, src)
}
func (m *Misbehaviour) XXX_Size() int {
	return m.Size()
}
func (m *Misbehaviour) XXX_DiscardUnknown() {
	xxx_messageInfo_Misbehaviour.DiscardUnknown(m)
}

var xxx_messageInfo_Misbehaviour proto.InternalMessageInfo

// ClientMessage for ics11-BEEFY
type ClientMessage struct {
	// One of these client message types
	//
	// Types that are valid to be assigned to Message:
	//
	//	*ClientMessage_Header
	//	*ClientMessage_Misbehaviour
	Message isClientMessage_Message `protobuf_oneof:"message"`
}

func (m *ClientMessage) Reset()         { *m = ClientMessage{} }
func (m *ClientMessage) String() string { return proto.CompactTextString(m) }
func (*ClientMessage) ProtoMessage()    {}
func (*ClientMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_7a90d4515db3d1ab, []int{14}
}
func (m *ClientMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClientMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClientMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClientMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientMessage.Merge(m, src)
}
func (m *ClientMessage) XXX_Size() int {
	return m.Size()
}
func (m *ClientMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientMessage.DiscardUnknown(m)
}

var xxx_messageInfo_ClientMessage proto.InternalMessageInfo

type isClientMessage_Message interface {
	isClientMessage_Message()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ClientMessage_Header struct {
	Header *Header `protobuf:"bytes,1,opt,name=header,proto3,oneof" json:"header,omitempty"`
}
type ClientMessage_Misbehaviour struct {
	Misbehaviour *Misbehaviour `protobuf:"bytes,2,opt,name=misbehaviour,proto3,oneof" json:"misbehaviour,omitempty"`
}

func (*ClientMessage_Header) isClientMessage_Message()       {}
func (*ClientMessage_Misbehaviour) isClientMessage_Message() {}

func (m *ClientMessage) GetMessage() isClientMessage_Message {
	if m != nil {
		return m.Message
	}
	return nil
}

func (m *ClientMessage) GetHeader() *Header {
	if x, ok := m.GetMessage().(*ClientMessage_Header); ok {
		return x.Header
	}
	return nil
}

func (m *ClientMessage) GetMisbehaviour() *Misbehaviour {
	if x, ok := m.GetMessage().(*ClientMessage_Misbehaviour); ok {
		return x.Misbehaviour
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ClientMessage) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ClientMessage_Header)(nil),
		(*ClientMessage_Misbehaviour)(nil),
	}
}

func init() {
	proto.RegisterEnum("ibc.lightclients.beefy.v1.RelayChain", RelayChain_name, RelayChain_value)
	proto.RegisterType((*ClientState)(nil), "ibc.lightclients.beefy.v1.ClientState")
	proto.RegisterType((*PayloadItem)(nil), "ibc.lightclients.beefy.v1.PayloadItem")
	proto.RegisterType((*Commitment)(nil), "ibc.lightclients.beefy.v1.Commitment")
	proto.RegisterType((*CommitmentSignature)(nil), "ibc.lightclients.beefy.v1.CommitmentSignature")
	proto.RegisterType((*SignedCommitment)(nil), "ibc.lightclients.beefy.v1.SignedCommitment")
	proto.RegisterType((*ClientStateUpdateProof)(nil), "ibc.lightclients.beefy.v1.ClientStateUpdateProof")
	proto.RegisterType((*ConsensusState)(nil), "ibc.lightclients.beefy.v1.ConsensusState")
	proto.RegisterType((*Header)(nil), "ibc.lightclients.beefy.v1.Header")
	proto.RegisterType((*ConsensusStateUpdateProof)(nil), "ibc.lightclients.beefy.v1.ConsensusStateUpdateProof")
	proto.RegisterType((*ParachainHeader)(nil), "ibc.lightclients.beefy.v1.ParachainHeader")
	proto.RegisterType((*BeefyMmrLeafPartial)(nil), "ibc.lightclients.beefy.v1.BeefyMmrLeafPartial")
	proto.RegisterType((*BeefyAuthoritySet)(nil), "ibc.lightclients.beefy.v1.BeefyAuthoritySet")
	proto.RegisterType((*BeefyMmrLeaf)(nil), "ibc.lightclients.beefy.v1.BeefyMmrLeaf")
	proto.RegisterType((*Misbehaviour)(nil), "ibc.lightclients.beefy.v1.Misbehaviour")
	proto.RegisterType((*ClientMessage)(nil), "ibc.lightclients.beefy.v1.ClientMessage")
}

func init() { proto.RegisterFile("substrate/beefy.proto", fileDescriptor_7a90d4515db3d1ab) }

var fileDescriptor_7a90d4515db3d1ab = []byte{
	// 1333 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x57, 0x4f, 0x73, 0x1b, 0xc5,
	0x12, 0xd7, 0x4a, 0x8a, 0x6c, 0xb5, 0x56, 0xf2, 0x7a, 0xfc, 0xf2, 0x9e, 0x92, 0x07, 0xb6, 0x62,
	0x08, 0x11, 0x49, 0x90, 0xca, 0x82, 0x13, 0x5c, 0xb0, 0x94, 0x50, 0x36, 0x89, 0xff, 0xd4, 0xd8,
	0x29, 0x52, 0xa9, 0xa2, 0xb6, 0x46, 0xab, 0x91, 0xb4, 0xb0, 0xbb, 0xa3, 0xda, 0x19, 0xb9, 0xe2,
	0x9c, 0x38, 0x70, 0xc8, 0x31, 0xdf, 0x00, 0x4e, 0x9c, 0xa8, 0xe2, 0x43, 0x70, 0xc9, 0x31, 0x47,
	0x8a, 0x03, 0x50, 0xce, 0x77, 0xe0, 0x4c, 0xcd, 0x9f, 0x5d, 0xad, 0x8c, 0x23, 0x52, 0x39, 0x72,
	0xdb, 0xf9, 0x75, 0xf7, 0xf4, 0xaf, 0x7b, 0xba, 0x7b, 0x66, 0xe1, 0x32, 0x9f, 0xf6, 0xb9, 0x88,
	0x89, 0xa0, 0xed, 0x3e, 0xa5, 0xc3, 0xd3, 0xd6, 0x24, 0x66, 0x82, 0xa1, 0x2b, 0x7e, 0xdf, 0x6b,
	0x05, 0xfe, 0x68, 0x2c, 0xbc, 0xc0, 0xa7, 0x91, 0xe0, 0x2d, 0x2d, 0x3d, 0xd9, 0xba, 0xfa, 0x9f,
	0x11, 0x1b, 0x31, 0xa5, 0xd5, 0x96, 0x5f, 0xda, 0xe0, 0xea, 0xc6, 0x88, 0xb1, 0x51, 0x40, 0xdb,
	0x6a, 0xd5, 0x9f, 0x0e, 0xdb, 0xc2, 0x0f, 0x29, 0x17, 0x24, 0x9c, 0x68, 0x85, 0xcd, 0x5f, 0x0b,
	0x50, 0xe9, 0xa9, 0xbd, 0x8e, 0x04, 0x11, 0x14, 0x6d, 0x42, 0x35, 0x0c, 0x63, 0x37, 0x66, 0x4c,
	0xb8, 0x63, 0xc2, 0xc7, 0x75, 0xab, 0x61, 0x35, 0x6d, 0x5c, 0x09, 0xc3, 0x18, 0x33, 0x26, 0x76,
	0x08, 0x1f, 0xa3, 0x16, 0xac, 0x05, 0x44, 0x50, 0x2e, 0x5c, 0xe5, 0xdd, 0x1d, 0x53, 0xc9, 0xa8,
	0x9e, 0x6f, 0x58, 0xcd, 0x2a, 0x5e, 0xd5, 0xa2, 0xae, 0x94, 0xec, 0x28, 0x01, 0x6a, 0x42, 0x75,
	0x18, 0xb3, 0x27, 0x34, 0x4a, 0x34, 0x0b, 0x0d, 0xab, 0x59, 0xdc, 0xc9, 0x61, 0x5b, 0xc3, 0x5a,
	0xed, 0xa9, 0x65, 0xa1, 0xcf, 0xa0, 0x12, 0xd3, 0x80, 0x9c, 0xba, 0xde, 0x98, 0xf8, 0x51, 0xbd,
	0xd8, 0xb0, 0x9a, 0xb5, 0xce, 0xf5, 0xd6, 0x2b, 0xa3, 0x6e, 0x61, 0xa9, 0xdd, 0x93, 0xca, 0x18,
	0xe2, 0xf4, 0x1b, 0xfd, 0x0f, 0x96, 0x26, 0x24, 0x26, 0xae, 0x3f, 0xa8, 0x5f, 0x52, 0xac, 0x4a,
	0x72, 0xb9, 0x3b, 0x40, 0xb7, 0x01, 0x19, 0xea, 0x4a, 0x6e, 0xf8, 0x94, 0x94, 0x8e, 0xa3, 0x25,
	0x87, 0x24, 0x26, 0x86, 0xf8, 0xe7, 0x50, 0x26, 0x53, 0x31, 0x66, 0xb1, 0x2f, 0x4e, 0xeb, 0xcb,
	0x0d, 0xab, 0x59, 0xe9, 0xdc, 0x5e, 0x40, 0x46, 0xc5, 0xbc, 0x9d, 0x18, 0x1c, 0x51, 0x81, 0x67,
	0xe6, 0xe8, 0x11, 0xa0, 0x88, 0x3e, 0x16, 0x6e, 0x8a, 0xb8, 0x9c, 0x8a, 0x7a, 0xf9, 0x0d, 0x36,
	0x75, 0xe4, 0x3e, 0x59, 0xe4, 0xe3, 0xe2, 0xd3, 0xef, 0x37, 0x72, 0x5d, 0x07, 0x6a, 0xee, 0x5c,
	0x9e, 0x37, 0x1f, 0x40, 0xe5, 0x90, 0x9c, 0x06, 0x8c, 0x0c, 0x76, 0x05, 0x0d, 0xd1, 0xdb, 0x00,
	0x13, 0xbd, 0x94, 0x89, 0xd1, 0x07, 0x5b, 0x36, 0xc8, 0xee, 0x00, 0x5d, 0x03, 0x3b, 0x11, 0x0f,
	0x88, 0x20, 0xea, 0x3c, 0x6d, 0x5c, 0x31, 0xd8, 0x1d, 0x22, 0x88, 0x76, 0xb4, 0xf9, 0x9d, 0x05,
	0xd0, 0x63, 0x61, 0xe8, 0x8b, 0x90, 0x46, 0x02, 0x7d, 0x2a, 0x93, 0xad, 0x74, 0xea, 0x56, 0xa3,
	0xd0, 0xac, 0x74, 0xde, 0x5b, 0x10, 0x4e, 0x86, 0x0f, 0x4e, 0xcc, 0xd0, 0x06, 0x54, 0xfa, 0x01,
	0xf3, 0xbe, 0x76, 0xa3, 0x69, 0x48, 0x63, 0x53, 0x48, 0xa0, 0xa0, 0x7d, 0x89, 0xa0, 0x26, 0x38,
	0x27, 0x24, 0xf0, 0x07, 0x44, 0xb0, 0x58, 0xe6, 0x4d, 0xf2, 0x57, 0x45, 0x84, 0x6b, 0x29, 0x7e,
	0x44, 0xc5, 0xee, 0xc0, 0x30, 0xec, 0xc3, 0xda, 0x8c, 0xe0, 0x91, 0x3f, 0x8a, 0x88, 0x98, 0xc6,
	0x14, 0xbd, 0x05, 0x65, 0x9e, 0x2c, 0x92, 0xf8, 0x53, 0x00, 0xdd, 0x80, 0x95, 0xd9, 0xe1, 0xf8,
	0xd1, 0x80, 0x3e, 0x36, 0x4c, 0x6a, 0x29, 0xbc, 0x2b, 0x51, 0xe3, 0xe3, 0x27, 0x0b, 0x1c, 0xb9,
	0x35, 0x1d, 0x64, 0x72, 0x71, 0x17, 0xc0, 0x4b, 0x57, 0xca, 0x45, 0x65, 0x61, 0xfd, 0xce, 0x4c,
	0x71, 0xc6, 0x10, 0xed, 0x03, 0xa4, 0xbc, 0x78, 0x3d, 0xaf, 0xb2, 0xda, 0x7a, 0xad, 0x6d, 0xd2,
	0x60, 0x71, 0x66, 0x07, 0xc3, 0xf8, 0xc7, 0x3c, 0xfc, 0x37, 0xd3, 0xeb, 0x0f, 0x26, 0x03, 0x22,
	0xe8, 0x61, 0xcc, 0xd8, 0x10, 0x75, 0x61, 0x59, 0xb6, 0x7d, 0x40, 0xc9, 0xd0, 0xb0, 0xbe, 0xf1,
	0x4f, 0x35, 0xb9, 0x17, 0xc6, 0xf7, 0x29, 0x19, 0xe2, 0xa5, 0x50, 0x7f, 0xa0, 0x77, 0xa1, 0x96,
	0xec, 0x91, 0x49, 0x5f, 0x11, 0xdb, 0x46, 0x41, 0x25, 0x0f, 0xfd, 0x1f, 0xca, 0x52, 0x6b, 0x22,
	0xdd, 0xd6, 0x0b, 0x8d, 0x42, 0xd3, 0xc6, 0xd2, 0xb5, 0xa6, 0xf1, 0x10, 0x56, 0xb9, 0x4a, 0xa9,
	0x9b, 0xc9, 0x62, 0x51, 0xf1, 0xb9, 0xb5, 0x80, 0xcf, 0xf9, 0x63, 0xc0, 0x0e, 0x3f, 0x7f, 0x30,
	0xb7, 0x60, 0x35, 0x39, 0x45, 0x9f, 0x72, 0xe3, 0xfe, 0x92, 0x72, 0xef, 0x64, 0x04, 0x8a, 0x86,
	0x49, 0x57, 0x04, 0xb5, 0x1e, 0x8b, 0x38, 0x8d, 0xf8, 0x94, 0xeb, 0xe1, 0xd8, 0x85, 0x72, 0x3a,
	0x3f, 0x4d, 0x9a, 0xae, 0xb6, 0xf4, 0x84, 0x6d, 0x25, 0x13, 0xb6, 0x75, 0x9c, 0x68, 0x74, 0x97,
	0x9f, 0xff, 0xb6, 0x91, 0x7b, 0xf6, 0xfb, 0x86, 0x85, 0x67, 0x66, 0x08, 0x41, 0x51, 0x0e, 0x57,
	0xd3, 0x5d, 0xea, 0xdb, 0xf8, 0xfb, 0xd9, 0x82, 0xd2, 0x0e, 0x25, 0x03, 0x1a, 0xa3, 0x2f, 0x61,
	0xc5, 0x4b, 0x5c, 0xbb, 0x5c, 0xfa, 0x36, 0xee, 0x3e, 0x5a, 0x58, 0x04, 0x59, 0xb2, 0x99, 0xd3,
	0xc5, 0x35, 0x6f, 0x3e, 0x8e, 0x63, 0xb0, 0xb5, 0xb5, 0xd9, 0x3b, 0xaf, 0xf6, 0xde, 0x5a, 0xb4,
	0xf7, 0x85, 0x65, 0x83, 0x2b, 0xde, 0x0c, 0x37, 0x51, 0xfc, 0x69, 0xc1, 0x95, 0x57, 0x32, 0x41,
	0x5f, 0xc0, 0xaa, 0x1c, 0xbc, 0x6a, 0xbc, 0xbb, 0x63, 0x15, 0x2c, 0x37, 0x53, 0xe3, 0xe6, 0xc2,
	0xa9, 0x61, 0x6c, 0x74, 0x7e, 0xb0, 0x33, 0x99, 0x07, 0xb8, 0x9c, 0x6d, 0x69, 0x59, 0xe9, 0x8e,
	0xb1, 0x71, 0x39, 0xa9, 0x2b, 0x8e, 0xae, 0xe8, 0xfa, 0xe6, 0xfe, 0x13, 0x6a, 0x06, 0x87, 0x2c,
	0xdb, 0x23, 0xff, 0x09, 0x95, 0x63, 0x2f, 0x29, 0x59, 0xdf, 0xa3, 0xbc, 0x5e, 0x6c, 0x14, 0x9a,
	0x45, 0x5c, 0x09, 0x74, 0xc5, 0x4a, 0x48, 0x6e, 0xae, 0x54, 0x3c, 0x36, 0x8d, 0x84, 0xba, 0x51,
	0x8a, 0xb8, 0x2c, 0x91, 0x9e, 0x04, 0x4c, 0xe0, 0xdf, 0x14, 0x60, 0xe5, 0x1c, 0x4f, 0xf4, 0x3e,
	0x38, 0xe7, 0xc3, 0x35, 0x73, 0x67, 0xe5, 0x5c, 0x04, 0xe8, 0x21, 0x38, 0x69, 0xf7, 0x4c, 0x48,
	0x2c, 0x7c, 0x12, 0x98, 0x73, 0x69, 0xbd, 0x66, 0x27, 0x1e, 0x6a, 0x2b, 0x5c, 0x0b, 0xe7, 0xd6,
	0xa8, 0x03, 0x97, 0xe7, 0x49, 0xf0, 0xb9, 0xee, 0x5b, 0x9b, 0x63, 0xa2, 0x3b, 0x40, 0x0e, 0x5c,
	0xad, 0x99, 0xe9, 0xe6, 0xa2, 0x1e, 0x86, 0x0a, 0x9f, 0xf5, 0xf3, 0x4d, 0x58, 0xd5, 0x9a, 0x82,
	0x09, 0x12, 0x64, 0x52, 0x54, 0xc5, 0x2b, 0x4a, 0x70, 0x2c, 0x71, 0x95, 0x28, 0x39, 0x61, 0xe9,
	0x63, 0x11, 0xfb, 0x11, 0xf7, 0x3d, 0xc3, 0xa1, 0xa4, 0x38, 0xd4, 0x52, 0x58, 0xbb, 0x6f, 0xc3,
	0x5a, 0xda, 0x31, 0x6e, 0x2a, 0xab, 0x2f, 0xa9, 0xd4, 0xa1, 0x54, 0x74, 0x37, 0x91, 0x98, 0x23,
	0x38, 0xb3, 0x60, 0xed, 0x82, 0x8c, 0xa0, 0x3a, 0x2c, 0x9d, 0xd0, 0x98, 0xfb, 0x2c, 0x52, 0xd9,
	0xaf, 0xe2, 0x64, 0x89, 0xde, 0x81, 0xea, 0x84, 0xc4, 0xb2, 0x13, 0xa2, 0x69, 0xd8, 0x4f, 0xef,
	0x1e, 0x5b, 0x83, 0xfb, 0x0a, 0x93, 0xd7, 0x93, 0x51, 0x52, 0x2f, 0xa2, 0x82, 0x62, 0x01, 0x1a,
	0x52, 0x0f, 0x22, 0x0a, 0x75, 0xfd, 0x12, 0xba, 0xe0, 0x86, 0x2f, 0xbe, 0xc1, 0x0d, 0x7f, 0x59,
	0xc9, 0xf6, 0x2f, 0xbc, 0xe6, 0x37, 0xfb, 0xb0, 0xfa, 0x37, 0x0b, 0x54, 0x83, 0xbc, 0xb9, 0xd2,
	0x8b, 0x38, 0xef, 0x0f, 0x90, 0x03, 0x85, 0x80, 0x46, 0x26, 0x1a, 0xf9, 0x89, 0xae, 0xc3, 0xec,
	0x1a, 0x53, 0xcf, 0x3b, 0x13, 0x47, 0x35, 0x45, 0xf1, 0x6c, 0x14, 0x7d, 0x9b, 0x07, 0x3b, 0x9b,
	0xc8, 0x7f, 0x49, 0x06, 0x65, 0x01, 0x9e, 0x6b, 0x05, 0x55, 0xaa, 0x36, 0xae, 0xcd, 0x37, 0x81,
	0x49, 0x43, 0x0d, 0xec, 0x3d, 0x9f, 0xf7, 0xe9, 0x98, 0x9c, 0xf8, 0x6c, 0x1a, 0x6f, 0xfe, 0x60,
	0x41, 0x55, 0x4f, 0xc2, 0x3d, 0xca, 0x39, 0x19, 0x51, 0xf4, 0x09, 0x94, 0x32, 0x6d, 0x5d, 0xe9,
	0x5c, 0x5b, 0xc0, 0x52, 0x37, 0xfa, 0x4e, 0x0e, 0x1b, 0x13, 0xb4, 0x07, 0x76, 0x98, 0xd9, 0xde,
	0xb4, 0xfb, 0xa2, 0x8b, 0x37, 0xcb, 0x46, 0xbe, 0x9f, 0xb3, 0xe6, 0xdd, 0x32, 0x2c, 0x85, 0x9a,
	0xd6, 0xcd, 0x0e, 0xc0, 0xec, 0x65, 0x8c, 0x6c, 0x58, 0x3e, 0x3c, 0xb8, 0x7f, 0x6f, 0xfb, 0xce,
	0xc1, 0xb1, 0x93, 0x43, 0x00, 0xa5, 0x7b, 0x0f, 0x8e, 0xb6, 0xf7, 0xb6, 0x1d, 0x4b, 0x7e, 0xe3,
	0x83, 0xde, 0x41, 0xef, 0xc0, 0xc9, 0x77, 0xbf, 0x7a, 0x7e, 0xb6, 0x6e, 0xbd, 0x38, 0x5b, 0xb7,
	0xfe, 0x38, 0x5b, 0xb7, 0x9e, 0xbd, 0x5c, 0xcf, 0xbd, 0x78, 0xb9, 0x9e, 0xfb, 0xe5, 0xe5, 0x7a,
	0xee, 0xd1, 0xe1, 0xc8, 0x17, 0xe3, 0x69, 0xbf, 0xe5, 0xb1, 0xb0, 0xed, 0x31, 0x1e, 0x32, 0xde,
	0x56, 0x6f, 0x6d, 0x1a, 0xb7, 0x4f, 0x3a, 0xe9, 0xa7, 0xca, 0x1e, 0x6f, 0xcf, 0x7e, 0x5c, 0x86,
	0x7e, 0x44, 0x02, 0x5f, 0x9c, 0xea, 0x3f, 0x98, 0xb6, 0xef, 0xf1, 0xad, 0xad, 0x0f, 0xc4, 0xe9,
	0x84, 0xf2, 0x7e, 0x49, 0xdd, 0x96, 0x1f, 0xfe, 0x15, 0x00, 0x00, 0xff, 0xff, 0xa9, 0x44, 0xe0,
	0xd8, 0xe7, 0x0c, 0x00, 0x00,
}

func (m *ClientState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NextAuthoritySet != nil {
		{
			size, err := m.NextAuthoritySet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBeefy(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.Authority != nil {
		{
			size, err := m.Authority.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBeefy(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.LatestParaHeight != 0 {
		i = encodeVarintBeefy(dAtA, i, uint64(m.LatestParaHeight))
		i--
		dAtA[i] = 0x30
	}
	if m.ParaId != 0 {
		i = encodeVarintBeefy(dAtA, i, uint64(m.ParaId))
		i--
		dAtA[i] = 0x28
	}
	if m.RelayChain != 0 {
		i = encodeVarintBeefy(dAtA, i, uint64(m.RelayChain))
		i--
		dAtA[i] = 0x20
	}
	if m.XFrozenHeight != nil {
		{
			size := m.XFrozenHeight.Size()
			i -= size
			if _, err := m.XFrozenHeight.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.LatestBeefyHeight != 0 {
		i = encodeVarintBeefy(dAtA, i, uint64(m.LatestBeefyHeight))
		i--
		dAtA[i] = 0x10
	}
	if len(m.MmrRootHash) > 0 {
		i -= len(m.MmrRootHash)
		copy(dAtA[i:], m.MmrRootHash)
		i = encodeVarintBeefy(dAtA, i, uint64(len(m.MmrRootHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClientState_FrozenHeight) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientState_FrozenHeight) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintBeefy(dAtA, i, uint64(m.FrozenHeight))
	i--
	dAtA[i] = 0x18
	return len(dAtA) - i, nil
}
func (m *PayloadItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PayloadItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PayloadItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PayloadData) > 0 {
		i -= len(m.PayloadData)
		copy(dAtA[i:], m.PayloadData)
		i = encodeVarintBeefy(dAtA, i, uint64(len(m.PayloadData)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PayloadId) > 0 {
		i -= len(m.PayloadId)
		copy(dAtA[i:], m.PayloadId)
		i = encodeVarintBeefy(dAtA, i, uint64(len(m.PayloadId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Commitment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Commitment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Commitment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ValidatorSetId != 0 {
		i = encodeVarintBeefy(dAtA, i, uint64(m.ValidatorSetId))
		i--
		dAtA[i] = 0x18
	}
	if m.BlockNumer != 0 {
		i = encodeVarintBeefy(dAtA, i, uint64(m.BlockNumer))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Payload) > 0 {
		for iNdEx := len(m.Payload) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Payload[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBeefy(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CommitmentSignature) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommitmentSignature) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CommitmentSignature) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AuthorityIndex != 0 {
		i = encodeVarintBeefy(dAtA, i, uint64(m.AuthorityIndex))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintBeefy(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SignedCommitment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SignedCommitment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SignedCommitment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Signatures) > 0 {
		for iNdEx := len(m.Signatures) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Signatures[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBeefy(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Commitment != nil {
		{
			size, err := m.Commitment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBeefy(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClientStateUpdateProof) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientStateUpdateProof) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientStateUpdateProof) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AuthoritiesProof) > 0 {
		for iNdEx := len(m.AuthoritiesProof) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AuthoritiesProof[iNdEx])
			copy(dAtA[i:], m.AuthoritiesProof[iNdEx])
			i = encodeVarintBeefy(dAtA, i, uint64(len(m.AuthoritiesProof[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.SignedCommitment != nil {
		{
			size, err := m.SignedCommitment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBeefy(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.MmrProof) > 0 {
		for iNdEx := len(m.MmrProof) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.MmrProof[iNdEx])
			copy(dAtA[i:], m.MmrProof[iNdEx])
			i = encodeVarintBeefy(dAtA, i, uint64(len(m.MmrProof[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.MmrLeafIndex != 0 {
		i = encodeVarintBeefy(dAtA, i, uint64(m.MmrLeafIndex))
		i--
		dAtA[i] = 0x10
	}
	if m.MmrLeaf != nil {
		{
			size, err := m.MmrLeaf.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBeefy(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ConsensusState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsensusState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConsensusState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Root) > 0 {
		i -= len(m.Root)
		copy(dAtA[i:], m.Root)
		i = encodeVarintBeefy(dAtA, i, uint64(len(m.Root)))
		i--
		dAtA[i] = 0x12
	}
	n6, err6 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.Timestamp, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.Timestamp):])
	if err6 != nil {
		return 0, err6
	}
	i -= n6
	i = encodeVarintBeefy(dAtA, i, uint64(n6))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Header) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Header) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Header) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ClientState != nil {
		{
			size, err := m.ClientState.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBeefy(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.ConsensusState != nil {
		{
			size, err := m.ConsensusState.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBeefy(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ConsensusStateUpdateProof) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsensusStateUpdateProof) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConsensusStateUpdateProof) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LeafCount != 0 {
		i = encodeVarintBeefy(dAtA, i, uint64(m.LeafCount))
		i--
		dAtA[i] = 0x28
	}
	if len(m.LeafIndices) > 0 {
		dAtA10 := make([]byte, len(m.LeafIndices)*10)
		var j9 int
		for _, num := range m.LeafIndices {
			for num >= 1<<7 {
				dAtA10[j9] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j9++
			}
			dAtA10[j9] = uint8(num)
			j9++
		}
		i -= j9
		copy(dAtA[i:], dAtA10[:j9])
		i = encodeVarintBeefy(dAtA, i, uint64(j9))
		i--
		dAtA[i] = 0x22
	}
	if m.MmrSize != 0 {
		i = encodeVarintBeefy(dAtA, i, uint64(m.MmrSize))
		i--
		dAtA[i] = 0x18
	}
	if len(m.MmrProofs) > 0 {
		for iNdEx := len(m.MmrProofs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.MmrProofs[iNdEx])
			copy(dAtA[i:], m.MmrProofs[iNdEx])
			i = encodeVarintBeefy(dAtA, i, uint64(len(m.MmrProofs[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.ParachainHeaders) > 0 {
		for iNdEx := len(m.ParachainHeaders) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ParachainHeaders[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBeefy(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ParachainHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ParachainHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ParachainHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TimestampExtrinsic) > 0 {
		i -= len(m.TimestampExtrinsic)
		copy(dAtA[i:], m.TimestampExtrinsic)
		i = encodeVarintBeefy(dAtA, i, uint64(len(m.TimestampExtrinsic)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.ExtrinsicProof) > 0 {
		for iNdEx := len(m.ExtrinsicProof) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ExtrinsicProof[iNdEx])
			copy(dAtA[i:], m.ExtrinsicProof[iNdEx])
			i = encodeVarintBeefy(dAtA, i, uint64(len(m.ExtrinsicProof[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if m.HeadsTotalCount != 0 {
		i = encodeVarintBeefy(dAtA, i, uint64(m.HeadsTotalCount))
		i--
		dAtA[i] = 0x28
	}
	if m.HeadsLeafIndex != 0 {
		i = encodeVarintBeefy(dAtA, i, uint64(m.HeadsLeafIndex))
		i--
		dAtA[i] = 0x20
	}
	if len(m.ParachainHeadsProof) > 0 {
		for iNdEx := len(m.ParachainHeadsProof) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ParachainHeadsProof[iNdEx])
			copy(dAtA[i:], m.ParachainHeadsProof[iNdEx])
			i = encodeVarintBeefy(dAtA, i, uint64(len(m.ParachainHeadsProof[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.MmrLeafPartial != nil {
		{
			size, err := m.MmrLeafPartial.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBeefy(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.ParachainHeader) > 0 {
		i -= len(m.ParachainHeader)
		copy(dAtA[i:], m.ParachainHeader)
		i = encodeVarintBeefy(dAtA, i, uint64(len(m.ParachainHeader)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BeefyMmrLeafPartial) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BeefyMmrLeafPartial) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BeefyMmrLeafPartial) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BeefyNextAuthoritySet != nil {
		{
			size, err := m.BeefyNextAuthoritySet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBeefy(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.ParentHash) > 0 {
		i -= len(m.ParentHash)
		copy(dAtA[i:], m.ParentHash)
		i = encodeVarintBeefy(dAtA, i, uint64(len(m.ParentHash)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ParentNumber != 0 {
		i = encodeVarintBeefy(dAtA, i, uint64(m.ParentNumber))
		i--
		dAtA[i] = 0x10
	}
	if m.Version != 0 {
		i = encodeVarintBeefy(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BeefyAuthoritySet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BeefyAuthoritySet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BeefyAuthoritySet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AuthorityRoot) > 0 {
		i -= len(m.AuthorityRoot)
		copy(dAtA[i:], m.AuthorityRoot)
		i = encodeVarintBeefy(dAtA, i, uint64(len(m.AuthorityRoot)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Len != 0 {
		i = encodeVarintBeefy(dAtA, i, uint64(m.Len))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintBeefy(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BeefyMmrLeaf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BeefyMmrLeaf) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BeefyMmrLeaf) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ParachainHeads) > 0 {
		i -= len(m.ParachainHeads)
		copy(dAtA[i:], m.ParachainHeads)
		i = encodeVarintBeefy(dAtA, i, uint64(len(m.ParachainHeads)))
		i--
		dAtA[i] = 0x2a
	}
	if m.BeefyNextAuthoritySet != nil {
		{
			size, err := m.BeefyNextAuthoritySet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBeefy(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.ParentHash) > 0 {
		i -= len(m.ParentHash)
		copy(dAtA[i:], m.ParentHash)
		i = encodeVarintBeefy(dAtA, i, uint64(len(m.ParentHash)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ParentNumber != 0 {
		i = encodeVarintBeefy(dAtA, i, uint64(m.ParentNumber))
		i--
		dAtA[i] = 0x10
	}
	if m.Version != 0 {
		i = encodeVarintBeefy(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Misbehaviour) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Misbehaviour) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Misbehaviour) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *ClientMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Message != nil {
		{
			size := m.Message.Size()
			i -= size
			if _, err := m.Message.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ClientMessage_Header) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientMessage_Header) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBeefy(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *ClientMessage_Misbehaviour) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientMessage_Misbehaviour) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Misbehaviour != nil {
		{
			size, err := m.Misbehaviour.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBeefy(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func encodeVarintBeefy(dAtA []byte, offset int, v uint64) int {
	offset -= sovBeefy(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ClientState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MmrRootHash)
	if l > 0 {
		n += 1 + l + sovBeefy(uint64(l))
	}
	if m.LatestBeefyHeight != 0 {
		n += 1 + sovBeefy(uint64(m.LatestBeefyHeight))
	}
	if m.XFrozenHeight != nil {
		n += m.XFrozenHeight.Size()
	}
	if m.RelayChain != 0 {
		n += 1 + sovBeefy(uint64(m.RelayChain))
	}
	if m.ParaId != 0 {
		n += 1 + sovBeefy(uint64(m.ParaId))
	}
	if m.LatestParaHeight != 0 {
		n += 1 + sovBeefy(uint64(m.LatestParaHeight))
	}
	if m.Authority != nil {
		l = m.Authority.Size()
		n += 1 + l + sovBeefy(uint64(l))
	}
	if m.NextAuthoritySet != nil {
		l = m.NextAuthoritySet.Size()
		n += 1 + l + sovBeefy(uint64(l))
	}
	return n
}

func (m *ClientState_FrozenHeight) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovBeefy(uint64(m.FrozenHeight))
	return n
}
func (m *PayloadItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PayloadId)
	if l > 0 {
		n += 1 + l + sovBeefy(uint64(l))
	}
	l = len(m.PayloadData)
	if l > 0 {
		n += 1 + l + sovBeefy(uint64(l))
	}
	return n
}

func (m *Commitment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Payload) > 0 {
		for _, e := range m.Payload {
			l = e.Size()
			n += 1 + l + sovBeefy(uint64(l))
		}
	}
	if m.BlockNumer != 0 {
		n += 1 + sovBeefy(uint64(m.BlockNumer))
	}
	if m.ValidatorSetId != 0 {
		n += 1 + sovBeefy(uint64(m.ValidatorSetId))
	}
	return n
}

func (m *CommitmentSignature) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovBeefy(uint64(l))
	}
	if m.AuthorityIndex != 0 {
		n += 1 + sovBeefy(uint64(m.AuthorityIndex))
	}
	return n
}

func (m *SignedCommitment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Commitment != nil {
		l = m.Commitment.Size()
		n += 1 + l + sovBeefy(uint64(l))
	}
	if len(m.Signatures) > 0 {
		for _, e := range m.Signatures {
			l = e.Size()
			n += 1 + l + sovBeefy(uint64(l))
		}
	}
	return n
}

func (m *ClientStateUpdateProof) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MmrLeaf != nil {
		l = m.MmrLeaf.Size()
		n += 1 + l + sovBeefy(uint64(l))
	}
	if m.MmrLeafIndex != 0 {
		n += 1 + sovBeefy(uint64(m.MmrLeafIndex))
	}
	if len(m.MmrProof) > 0 {
		for _, b := range m.MmrProof {
			l = len(b)
			n += 1 + l + sovBeefy(uint64(l))
		}
	}
	if m.SignedCommitment != nil {
		l = m.SignedCommitment.Size()
		n += 1 + l + sovBeefy(uint64(l))
	}
	if len(m.AuthoritiesProof) > 0 {
		for _, b := range m.AuthoritiesProof {
			l = len(b)
			n += 1 + l + sovBeefy(uint64(l))
		}
	}
	return n
}

func (m *ConsensusState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.Timestamp)
	n += 1 + l + sovBeefy(uint64(l))
	l = len(m.Root)
	if l > 0 {
		n += 1 + l + sovBeefy(uint64(l))
	}
	return n
}

func (m *Header) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConsensusState != nil {
		l = m.ConsensusState.Size()
		n += 1 + l + sovBeefy(uint64(l))
	}
	if m.ClientState != nil {
		l = m.ClientState.Size()
		n += 1 + l + sovBeefy(uint64(l))
	}
	return n
}

func (m *ConsensusStateUpdateProof) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ParachainHeaders) > 0 {
		for _, e := range m.ParachainHeaders {
			l = e.Size()
			n += 1 + l + sovBeefy(uint64(l))
		}
	}
	if len(m.MmrProofs) > 0 {
		for _, b := range m.MmrProofs {
			l = len(b)
			n += 1 + l + sovBeefy(uint64(l))
		}
	}
	if m.MmrSize != 0 {
		n += 1 + sovBeefy(uint64(m.MmrSize))
	}
	if len(m.LeafIndices) > 0 {
		l = 0
		for _, e := range m.LeafIndices {
			l += sovBeefy(uint64(e))
		}
		n += 1 + sovBeefy(uint64(l)) + l
	}
	if m.LeafCount != 0 {
		n += 1 + sovBeefy(uint64(m.LeafCount))
	}
	return n
}

func (m *ParachainHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ParachainHeader)
	if l > 0 {
		n += 1 + l + sovBeefy(uint64(l))
	}
	if m.MmrLeafPartial != nil {
		l = m.MmrLeafPartial.Size()
		n += 1 + l + sovBeefy(uint64(l))
	}
	if len(m.ParachainHeadsProof) > 0 {
		for _, b := range m.ParachainHeadsProof {
			l = len(b)
			n += 1 + l + sovBeefy(uint64(l))
		}
	}
	if m.HeadsLeafIndex != 0 {
		n += 1 + sovBeefy(uint64(m.HeadsLeafIndex))
	}
	if m.HeadsTotalCount != 0 {
		n += 1 + sovBeefy(uint64(m.HeadsTotalCount))
	}
	if len(m.ExtrinsicProof) > 0 {
		for _, b := range m.ExtrinsicProof {
			l = len(b)
			n += 1 + l + sovBeefy(uint64(l))
		}
	}
	l = len(m.TimestampExtrinsic)
	if l > 0 {
		n += 1 + l + sovBeefy(uint64(l))
	}
	return n
}

func (m *BeefyMmrLeafPartial) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Version != 0 {
		n += 1 + sovBeefy(uint64(m.Version))
	}
	if m.ParentNumber != 0 {
		n += 1 + sovBeefy(uint64(m.ParentNumber))
	}
	l = len(m.ParentHash)
	if l > 0 {
		n += 1 + l + sovBeefy(uint64(l))
	}
	if m.BeefyNextAuthoritySet != nil {
		l = m.BeefyNextAuthoritySet.Size()
		n += 1 + l + sovBeefy(uint64(l))
	}
	return n
}

func (m *BeefyAuthoritySet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovBeefy(uint64(m.Id))
	}
	if m.Len != 0 {
		n += 1 + sovBeefy(uint64(m.Len))
	}
	l = len(m.AuthorityRoot)
	if l > 0 {
		n += 1 + l + sovBeefy(uint64(l))
	}
	return n
}

func (m *BeefyMmrLeaf) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Version != 0 {
		n += 1 + sovBeefy(uint64(m.Version))
	}
	if m.ParentNumber != 0 {
		n += 1 + sovBeefy(uint64(m.ParentNumber))
	}
	l = len(m.ParentHash)
	if l > 0 {
		n += 1 + l + sovBeefy(uint64(l))
	}
	if m.BeefyNextAuthoritySet != nil {
		l = m.BeefyNextAuthoritySet.Size()
		n += 1 + l + sovBeefy(uint64(l))
	}
	l = len(m.ParachainHeads)
	if l > 0 {
		n += 1 + l + sovBeefy(uint64(l))
	}
	return n
}

func (m *Misbehaviour) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *ClientMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Message != nil {
		n += m.Message.Size()
	}
	return n
}

func (m *ClientMessage_Header) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovBeefy(uint64(l))
	}
	return n
}
func (m *ClientMessage_Misbehaviour) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Misbehaviour != nil {
		l = m.Misbehaviour.Size()
		n += 1 + l + sovBeefy(uint64(l))
	}
	return n
}

func sovBeefy(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozBeefy(x uint64) (n int) {
	return sovBeefy(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ClientState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeefy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MmrRootHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MmrRootHash = append(m.MmrRootHash[:0], dAtA[iNdEx:postIndex]...)
			if m.MmrRootHash == nil {
				m.MmrRootHash = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatestBeefyHeight", wireType)
			}
			m.LatestBeefyHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LatestBeefyHeight |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrozenHeight", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.XFrozenHeight = &ClientState_FrozenHeight{v}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelayChain", wireType)
			}
			m.RelayChain = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RelayChain |= RelayChain(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParaId", wireType)
			}
			m.ParaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParaId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatestParaHeight", wireType)
			}
			m.LatestParaHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LatestParaHeight |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Authority == nil {
				m.Authority = &BeefyAuthoritySet{}
			}
			if err := m.Authority.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextAuthoritySet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NextAuthoritySet == nil {
				m.NextAuthoritySet = &BeefyAuthoritySet{}
			}
			if err := m.NextAuthoritySet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeefy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBeefy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PayloadItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeefy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PayloadItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PayloadItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayloadId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PayloadId = append(m.PayloadId[:0], dAtA[iNdEx:postIndex]...)
			if m.PayloadId == nil {
				m.PayloadId = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayloadData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PayloadData = append(m.PayloadData[:0], dAtA[iNdEx:postIndex]...)
			if m.PayloadData == nil {
				m.PayloadData = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeefy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBeefy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Commitment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeefy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Commitment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Commitment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload, &PayloadItem{})
			if err := m.Payload[len(m.Payload)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockNumer", wireType)
			}
			m.BlockNumer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockNumer |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorSetId", wireType)
			}
			m.ValidatorSetId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValidatorSetId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBeefy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBeefy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommitmentSignature) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeefy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommitmentSignature: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommitmentSignature: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthorityIndex", wireType)
			}
			m.AuthorityIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthorityIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBeefy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBeefy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SignedCommitment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeefy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SignedCommitment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SignedCommitment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commitment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Commitment == nil {
				m.Commitment = &Commitment{}
			}
			if err := m.Commitment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signatures", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signatures = append(m.Signatures, &CommitmentSignature{})
			if err := m.Signatures[len(m.Signatures)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeefy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBeefy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClientStateUpdateProof) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeefy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientStateUpdateProof: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientStateUpdateProof: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MmrLeaf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MmrLeaf == nil {
				m.MmrLeaf = &BeefyMmrLeaf{}
			}
			if err := m.MmrLeaf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MmrLeafIndex", wireType)
			}
			m.MmrLeafIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MmrLeafIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MmrProof", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MmrProof = append(m.MmrProof, make([]byte, postIndex-iNdEx))
			copy(m.MmrProof[len(m.MmrProof)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignedCommitment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SignedCommitment == nil {
				m.SignedCommitment = &SignedCommitment{}
			}
			if err := m.SignedCommitment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthoritiesProof", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthoritiesProof = append(m.AuthoritiesProof, make([]byte, postIndex-iNdEx))
			copy(m.AuthoritiesProof[len(m.AuthoritiesProof)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeefy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBeefy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConsensusState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeefy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsensusState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsensusState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.Timestamp, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Root", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Root = append(m.Root[:0], dAtA[iNdEx:postIndex]...)
			if m.Root == nil {
				m.Root = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeefy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBeefy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Header) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeefy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Header: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Header: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsensusState", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConsensusState == nil {
				m.ConsensusState = &ConsensusStateUpdateProof{}
			}
			if err := m.ConsensusState.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientState", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClientState == nil {
				m.ClientState = &ClientStateUpdateProof{}
			}
			if err := m.ClientState.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeefy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBeefy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConsensusStateUpdateProof) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeefy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsensusStateUpdateProof: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsensusStateUpdateProof: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParachainHeaders", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParachainHeaders = append(m.ParachainHeaders, &ParachainHeader{})
			if err := m.ParachainHeaders[len(m.ParachainHeaders)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MmrProofs", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MmrProofs = append(m.MmrProofs, make([]byte, postIndex-iNdEx))
			copy(m.MmrProofs[len(m.MmrProofs)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MmrSize", wireType)
			}
			m.MmrSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MmrSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBeefy
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.LeafIndices = append(m.LeafIndices, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBeefy
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBeefy
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthBeefy
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.LeafIndices) == 0 {
					m.LeafIndices = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBeefy
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.LeafIndices = append(m.LeafIndices, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field LeafIndices", wireType)
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeafCount", wireType)
			}
			m.LeafCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LeafCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBeefy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBeefy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ParachainHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeefy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ParachainHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ParachainHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParachainHeader", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParachainHeader = append(m.ParachainHeader[:0], dAtA[iNdEx:postIndex]...)
			if m.ParachainHeader == nil {
				m.ParachainHeader = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MmrLeafPartial", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MmrLeafPartial == nil {
				m.MmrLeafPartial = &BeefyMmrLeafPartial{}
			}
			if err := m.MmrLeafPartial.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParachainHeadsProof", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParachainHeadsProof = append(m.ParachainHeadsProof, make([]byte, postIndex-iNdEx))
			copy(m.ParachainHeadsProof[len(m.ParachainHeadsProof)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeadsLeafIndex", wireType)
			}
			m.HeadsLeafIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeadsLeafIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeadsTotalCount", wireType)
			}
			m.HeadsTotalCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeadsTotalCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtrinsicProof", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExtrinsicProof = append(m.ExtrinsicProof, make([]byte, postIndex-iNdEx))
			copy(m.ExtrinsicProof[len(m.ExtrinsicProof)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimestampExtrinsic", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TimestampExtrinsic = append(m.TimestampExtrinsic[:0], dAtA[iNdEx:postIndex]...)
			if m.TimestampExtrinsic == nil {
				m.TimestampExtrinsic = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeefy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBeefy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BeefyMmrLeafPartial) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeefy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BeefyMmrLeafPartial: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BeefyMmrLeafPartial: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentNumber", wireType)
			}
			m.ParentNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParentNumber |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentHash = append(m.ParentHash[:0], dAtA[iNdEx:postIndex]...)
			if m.ParentHash == nil {
				m.ParentHash = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BeefyNextAuthoritySet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BeefyNextAuthoritySet == nil {
				m.BeefyNextAuthoritySet = &BeefyAuthoritySet{}
			}
			if err := m.BeefyNextAuthoritySet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeefy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBeefy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BeefyAuthoritySet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeefy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BeefyAuthoritySet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BeefyAuthoritySet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Len", wireType)
			}
			m.Len = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Len |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthorityRoot", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthorityRoot = append(m.AuthorityRoot[:0], dAtA[iNdEx:postIndex]...)
			if m.AuthorityRoot == nil {
				m.AuthorityRoot = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeefy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBeefy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BeefyMmrLeaf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeefy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BeefyMmrLeaf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BeefyMmrLeaf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentNumber", wireType)
			}
			m.ParentNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParentNumber |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentHash = append(m.ParentHash[:0], dAtA[iNdEx:postIndex]...)
			if m.ParentHash == nil {
				m.ParentHash = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BeefyNextAuthoritySet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BeefyNextAuthoritySet == nil {
				m.BeefyNextAuthoritySet = &BeefyAuthoritySet{}
			}
			if err := m.BeefyNextAuthoritySet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParachainHeads", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParachainHeads = append(m.ParachainHeads[:0], dAtA[iNdEx:postIndex]...)
			if m.ParachainHeads == nil {
				m.ParachainHeads = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeefy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBeefy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Misbehaviour) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeefy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Misbehaviour: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Misbehaviour: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipBeefy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBeefy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClientMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeefy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Header{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &ClientMessage_Header{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Misbehaviour", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeefy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeefy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Misbehaviour{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &ClientMessage_Misbehaviour{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeefy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBeefy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipBeefy(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowBeefy
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBeefy
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthBeefy
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupBeefy
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthBeefy
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthBeefy        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowBeefy          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupBeefy = fmt.Errorf("proto: unexpected end of group")
)
